<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Dynamic Grid with Block Compaction</title>
<style>
  body {
    margin: 0;
    display: grid;
    grid-template-rows: repeat(12, 1fr);
    grid-template-columns: 1fr 1fr 1.75fr 1fr 1fr; /* Adjusted main column width */
    height: 100vh;
    background: black;
  }

  .cell {
    border: 1px transparent; /* Transparent cell borders */
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
  }

  .block {
    background: rgba(255, 255, 255, 0); /* Fully transparent block background */
    color: white;
    width: 80%;
    height: 80%;
    font-size: .8rem;
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 5px;
    cursor: grab;
    position: relative;
    transition: all 0.3s ease;
  }

  .block.trash {
    color: gray;
    font-size: .65rem;
  }

  .delete-btn {
    position: absolute;
    top: 1px;
    right: 1px;
    background: transparent; /* Transparent delete button background */
    color: white;
    border: none;
    border-radius: 50%;
    width: 1px;
    height: 10px;
    font-size: 12px;
    cursor: pointer;
    display: none;
  }

  .block:not(.trash):hover .delete-btn {
    display: block;
  }

  .editable {
    border: none;
    background: transparent;
    color: inherit;
    font-size: inherit;
    text-align: center;
    outline: none;
    width: auto;
  }
</style>
</head>
<body>
<script>
  const rows = 12;
  const cols = 5;
  const mainColumn = Math.floor(cols / 2);
  let draggedBlock = null;

  function initializeGrid() {
    const fragment = document.createDocumentFragment();
    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < cols; col++) {
        const cell = document.createElement("div");
        cell.classList.add("cell");
        cell.dataset.row = row;
        cell.dataset.col = col;
        fragment.appendChild(cell);
      }
    }
    document.body.appendChild(fragment);
  }

  function createBlock(content, isTrash = false, blockIndex = null) {
    const block = document.createElement("div");
    block.classList.add("block");
    block.draggable = true;

    // Word limit for blanks
    const maxWords = 3;

    // Handle fill-in-the-blank template for new blocks
    if (content === "New Block") {
      const template = "This is ___ for ___."; // Example template
      const parts = template.split("___");

      parts.forEach((part, index) => {
        const span = document.createElement("span");
        span.textContent = part; // Non-editable part
        block.appendChild(span);

        if (index < parts.length - 1) {
          const blank = document.createElement("span");
          blank.contentEditable = "true"; // Editable blank
          blank.classList.add("editable");
          blank.textContent = "______"; // Placeholder for blank

          // Add word limit enforcement
          blank.addEventListener("input", () => {
            const words = blank.textContent.trim().split(/\s+/);
            if (words.length > maxWords) {
              blank.textContent = words.slice(0, maxWords).join(" "); // Trim to maxWords
            }
          });

          block.appendChild(blank);
        }
      });
    } else {
      // Regular block content
      const text = document.createElement("div");
      text.textContent = content;
      text.innerHTML = content.replace(/\n/g, "<br>"); // Convert \n to <br> for line breaks
      text.classList.add("editable");
      block.appendChild(text);
    }

    // Add delete button for non-fixed blocks
    if (!isTrash && blockIndex !== 1 && blockIndex !== 10) {
      const deleteBtn = document.createElement("button");
      deleteBtn.textContent = "X";
      deleteBtn.classList.add("delete-btn");
      deleteBtn.addEventListener("click", () => deleteBlock(block));
      block.appendChild(deleteBtn);
    } else if (blockIndex === 1 || blockIndex === 10) {
      block.dataset.fixed = "true"; // Mark fixed blocks
    }

    block.addEventListener("dragstart", onDragStart);
    block.addEventListener("dragend", onDragEnd);

    return block;
  }

  function deleteBlock(block) {
    if (block.dataset.fixed === "true") {
      console.warn("Cannot delete Fixed Top or Block 10.");
      return;
    }

    const parentCell = block.parentElement;
    if (!parentCell) return;

    sendBlockToNearestTrash(block, parentCell);

    const newBlock = createBlock("New Block", false, true);
    parentCell.appendChild(newBlock);

    collapseMainColumn();
  }

  function sendBlockToNearestTrash(block, originCell) {
    const trashCells = Array.from(document.querySelectorAll(`.cell:not([data-col="${mainColumn}"])`));
    const originRow = parseInt(originCell.dataset.row, 10);

    // Filter cells in the same row
    const sameRowCells = trashCells.filter((cell) => parseInt(cell.dataset.row, 10) === originRow);

    // Sort cells in the same row by column proximity to the main column
    const sortedSameRowCells = sameRowCells.sort((a, b) => {
      const colA = Math.abs(parseInt(a.dataset.col, 10) - mainColumn);
      const colB = Math.abs(parseInt(b.dataset.col, 10) - mainColumn);
      return colA - colB; // Prioritize closer columns
    });

    // Check for the nearest empty cell in the same row
    const nearestSameRowCell = sortedSameRowCells.find((cell) => !cell.querySelector(".block"));

    if (nearestSameRowCell) {
      nearestSameRowCell.appendChild(block); // Move block to the nearest empty cell in the same row
      block.classList.add("trash"); // Add trash-specific styling
      block.querySelector(".editable").contentEditable = false; // Make block non-editable in trash
      return;
    }

    // Expand to other rows if no cell in the same row is available
    const rowsAboveAndBelow = trashCells.filter((cell) => parseInt(cell.dataset.row, 10) !== originRow);

    // Sort rows alternately above and below the origin row and prioritize column proximity
    const sortedOtherRowCells = rowsAboveAndBelow.sort((a, b) => {
      const rowA = parseInt(a.dataset.row, 10);
      const rowB = parseInt(b.dataset.row, 10);

      const rowDiffA = Math.abs(rowA - originRow);
      const rowDiffB = Math.abs(rowB - originRow);

      // If rows are equally distant, sort by proximity to the main column
      if (rowDiffA === rowDiffB) {
        const colA = Math.abs(parseInt(a.dataset.col, 10) - mainColumn);
        const colB = Math.abs(parseInt(b.dataset.col, 10) - mainColumn);
        return colA - colB;
      }

      return rowDiffA - rowDiffB;
    });

    // Find the nearest empty cell in other rows
    const nearestOtherRowCell = sortedOtherRowCells.find((cell) => !cell.querySelector(".block"));

    if (nearestOtherRowCell) {
      nearestOtherRowCell.appendChild(block); // Move block to the nearest empty cell in other rows
      block.classList.add("trash"); // Add trash-specific styling
      block.querySelector(".editable").contentEditable = false; // Make block non-editable in trash
    } else {
      console.warn("No empty space in the trash.");
    }
  }

  function collapseMainColumn() {
    const mainCells = Array.from(document.querySelectorAll(`.cell[data-col="${mainColumn}"]`));

    for (let i = 1; i < mainCells.length - 2; i++) { // Avoid collapsing into Block 10
      const currentCell = mainCells[i];
      if (!currentCell.querySelector(".block")) {
        for (let j = i + 1; j < mainCells.length - 1; j++) {
          const nextCell = mainCells[j];
          const blockToMove = nextCell.querySelector(".block");
          if (blockToMove) {
            currentCell.appendChild(blockToMove);
            break;
          }
        }
      }
    }
  }

  function pushBlockDown(block, targetCell) {
    const mainCells = Array.from(document.querySelectorAll(`.cell[data-col="${mainColumn}"]`));
    const targetIndex = mainCells.indexOf(targetCell);

    // Prevent pushing into the cell below Block 10
    if (targetIndex >= mainCells.length - 2) {
      console.warn("Cannot push blocks below Block 10.");
      return;
    }

    const nextCell = mainCells[targetIndex + 1];

    if (nextCell.querySelector(".block")) {
      const blockToPush = nextCell.querySelector(".block");
      pushBlockDown(blockToPush, nextCell);
    }

    nextCell.appendChild(block);
  }

  function placeBlockInMain(block, targetCell) {
    const mainCells = Array.from(document.querySelectorAll(`.cell[data-col="${mainColumn}"]`));
    const targetIndex = mainCells.indexOf(targetCell);

    // Count the total number of blocks in the main column
    const totalBlocks = mainCells.reduce((count, cell) => count + (cell.querySelector(".block") ? 1 : 0), 0);

    // Prevent exceeding 10 blocks
    if (totalBlocks >= 10 && !block.parentElement) {
      console.warn("Cannot add more than 10 blocks to the main column.");
      return;
    }

    // Restrict placement to middle cells and avoid placing below Block 10
    if (targetIndex <= 0 || targetIndex >= mainCells.length - 1) {
      console.warn("Blocks cannot replace Fixed Top or Block 10.");
      return;
    }

    // Prevent placing blocks in the cell directly below Block 10
    if (targetIndex === mainCells.length - 2) {
      console.warn("Cannot place blocks below Block 10.");
      return;
    }

    // Check if the block is from the trash
    if (block.classList.contains("trash")) {
      // Replace the block in the target cell
      if (targetCell.querySelector(".block")) {
        const existingBlock = targetCell.querySelector(".block");
        sendBlockToNearestTrash(existingBlock, targetCell); // Send the replaced block to the trash
      }
      targetCell.appendChild(block); // Place the block from the trash
      block.classList.remove("trash"); // Remove trash-specific styling
      block.querySelector(".editable").contentEditable = false; // Trash blocks become non-editable
    } else {
      // Handle blocks already in the main column
      if (targetCell.querySelector(".block")) {
        const existingBlock = targetCell.querySelector(".block");
        pushBlockDown(existingBlock, targetCell); // Push down the existing block
      }
      targetCell.appendChild(block); // Place the dragged block
    }

    // Compact the column after placement
    collapseMainColumn();
  }

  function onDragStart(e) {
    draggedBlock = e.target;
    draggedBlock.classList.add("dragging");
  }

  function onDragEnd() {
    if (draggedBlock) {
      draggedBlock.classList.remove("dragging");
      draggedBlock = null;
    }
  }

  function onDrop(e) {
    e.preventDefault();
    const x = e.clientX;
    const y = e.clientY;

    if (!draggedBlock) return;

    const nearestCell = findNearestCell(x, y);
    if (nearestCell) {
      const col = nearestCell.dataset.col;

      if (col == mainColumn.toString()) {
        placeBlockInMain(draggedBlock, nearestCell);
      } else {
        console.warn("Blocks can only be moved within the main column.");
      }
    }
  }

  function findNearestCell(x, y) {
    const cells = Array.from(document.querySelectorAll(".cell"));
    let nearestCell = null;
    let minDistance = Infinity;

    cells.forEach((cell) => {
      const rect = cell.getBoundingClientRect();
      const cellCenterX = rect.left + rect.width / 2;
      const cellCenterY = rect.top + rect.height / 2;
      const distance = Math.hypot(cellCenterX - x, cellCenterY - y);
      if (distance < minDistance) {
        nearestCell = cell;
        minDistance = distance;
      }
    });

    return nearestCell;
  }

  function allowDrop(e) {
    e.preventDefault();
  }

  initializeGrid();

  // Add blocks with content for each line
const mainCells = document.querySelectorAll(`.cell[data-col="${mainColumn}"]`);

mainCells[0].appendChild(createBlock("Where are you now? Who lies beneath your spell tonight?<br>Whom else from rapture’s road will you expel tonight?", false, 1));

mainCells[1].appendChild(createBlock("Those “Fabrics of Cashmere—” “to make Me beautiful—”<br>“Trinket”—to gem—“Me to adorn—How tell”—tonight?", false, 2));

mainCells[2].appendChild(createBlock("I beg for haven: Prisons, let open your gates—<br>A refugee from Belief seeks a cell tonight.", false, 3));

mainCells[3].appendChild(createBlock("God’s vintage loneliness has turned to vinegar—<br>All the archangels—their wings frozen—fell tonight.", false, 4));

mainCells[4].appendChild(createBlock("Lord, cried out the idols, Don’t let us be broken;<br>Only we can convert the infidel tonight.", false, 5));

mainCells[5].appendChild(createBlock("Mughal ceilings, let your mirrored convexities<br>multiply me at once under your spell tonight.", false, 6));

mainCells[6].appendChild(createBlock("He’s freed some fire from ice in pity for Heaven.<br>He’s left open—for God—the doors of Hell tonight.", false, 7));

mainCells[7].appendChild(createBlock("In the heart’s veined temple, all statues have been smashed.<br>No priest in saffron’s left to toll its knell tonight.", false, 8));

mainCells[8].appendChild(createBlock("God, limit these punishments, there’s still Judgment Day—<br>I’m a mere sinner, I’m no infidel tonight.", false, 9));

mainCells[9].appendChild(createBlock("Executioners near the woman at the window.<br>Damn you, Elijah, I’ll bless Jezebel tonight.", false, 10));
  document.querySelectorAll(".cell").forEach((cell) => {
    cell.addEventListener("dragover", allowDrop);
    cell.addEventListener("drop", onDrop);
  });
</script>
</body>
</html>
